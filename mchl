#!/usr/bin/env perl
# --------------------------------------------------
# Script which when given minecraft log, highlights user chatting and
# login/logoff with unique and persistent colors.
#
# Usage:
#   hl /path/to/logs/latest.log
#
# It can be passed through less, like so:
#   hl /path/to/logs/latest.log | less -R
#
# And used together with docker logs
#   docker logs <world> -f | hl
#
# --------------------------------------------------
# Mattias Jansson <fimblo@yanson.org>
# --------------------------------------------------

use MIME::Base64 qw(encode_base64);
use strict;

# user to color mapping is kept here
my $color_code = {};
my $test_rgb = {};

# Ansi terminal escape sequence to revert all color-coding
my $reset_color = "\033[0m";

&test_colors();

# Main loop
while (<>) {
  &colorize($_);
}





# ==================================================
# Subs

# --------------------------------------------------
# Figure out what color a user should get, and store it in the hash
# $color_code. If the user-color mapping already exists, do nothing.
sub determine_user_color {
  my $user = $_[0];
  return if (exists($color_code->{$user}));

  # Minimize number of possible chars in username
  # Total possibilities is now 26
  my $id = uc $user;       # upper case
  $id =~ s/[^A-Z]//g;      # strip non alphas
  $id =~ $id.$id.$id.$id ; # extend string size for short ids

  # Convert base64 to ascii decimal.
  my @nums =
    map { $_ * 10 } # numbers 0-250
    map { $_ % 26 } # numbers 0-25
    map { ord }     # numbers 65-90
  split('', $id);

  # If the RGB values are too close, make one different
  # deterministically
  my $range = 40;
  if ( abs($nums[0] - $nums[1] ) < $range  &&
       abs($nums[1] - $nums[2] ) < $range  &&
       abs($nums[2] - $nums[0] ) < $range ) {
    my $index = ($nums[4]/3) % 3;
    $nums[$index] = ($nums[$index] + 100) % 256;
  }

  # If RGB is too dark, make one different deterministically
   if ( $nums[0] < 40 &&
        $nums[1] < 40 &&
        $nums[2] < 40 ) {
    my $index = ($nums[4]/3) % 3;
    $nums[$index] = ($nums[$index] + 100) % 256;
  }

  # Blue is a pain, since most terminals have a black background.
  # The blue which is hard to see has high B and low G values.
  if ($nums[2] > 200 && $nums[1] < 80) {
    $nums[1] += 80;
  }
  
  $test_rgb -> {$user} -> {'r'} = $nums[0];
  $test_rgb -> {$user} -> {'g'} = $nums[1];
  $test_rgb -> {$user} -> {'b'} = $nums[2];

  # enter color code for this user to map
  $color_code->{$user} = join ('',
                             (
                              "\033[38;2;",   # Initiate color-coding
                              $nums[0] , ";", # red
                              $nums[1] , ";", # green
                              $nums[2] , "m"  # blue
                             ));
  return;
}


# --------------------------------------------------
# Color-code if the line contains a chat message or if a user logs in
# or logs out. Otherwise, print line as-is.
sub colorize {
  my $line = $_[0];
  chomp $line; # remove newline

  my ($prefix, $username, $message);
  if ($line =~ m|^(.*?\[Server thread/INFO\]: )<(.*?)>(.*?)$|) {
    $prefix   = $1;
    $username = $2;
    $message  = $3;

    &determine_user_color($username);

    print
      $prefix .
      $color_code->{$username} .
      "<$username>" . 
      $message . 
      $reset_color . "\n";
      
  }
  elsif ($line =~ m|^(.*?\[Server thread/INFO\]:) (.*?) (.*? the game)$|) {
    $prefix   = $1;
    $username = $2;
    $message  = $3;

    &determine_user_color($username);

    print
      $prefix .
      $color_code->{$username} .
      " $username " . 
      $message . 
      $reset_color . "\n";
    

}
  else {
    print $line . "\n";
  }
}

sub test_colors() {
  my @usernames = qw/BomberThug
    ekniberg
    Etshiko
    fimblo
    Framistan
    Maartini
    Pandie_
    Quint_
    Svantius
    Trrookk1000
    Wolf_Tail/;

  for my $u (@usernames) {
    &determine_user_color($u);

        print
          $color_code->{$u} .
          "$u" . 
          $reset_color .
          "\tR:" . $test_rgb->{$u}->{'r'} .
          " G:" . $test_rgb->{$u}->{'g'} .
          " B:" . $test_rgb->{$u}->{'b'} .
          "\n";
          
  }

  exit 0;
}

#print "\033[38;2;255;82;197;48;2;155;106;0mHello\033[0m\n";
